\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts, mathrsfs}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings} 
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand\tab[1][0.3cm]{\hspace*{#1}}
\title{Project Report - CMPT 417}
\author{Luiz Fernando Peres de Oliveira - 301288301 - lperesde@sfu.ca}
\date{December 1st, 2017}
\begin{document}
\maketitle
\section{Introduction}
This project aims to solve the \textbf{Pizza} problem given in the \textit{LP/CP Programming Contest 2015}, where some students in the University College Cork want to make a large order of pizza for a party such that they use as many vouchers collected throughout the year as they can. The final objective is to use the vouchers so to obtain all ordered pizzas with the least possible cost.
\\
\\
\tab Because we want to minimize the total possible cost for all ordered pizzas, the problem is then an optimization problem and not only satisfiability, meaning that we start our initial $K$, where $K$ is our target cost, with the sum of prices of all pizzas with no vouchers used, as this is the maximum possible cost for this problem and, therefore, if we were to choose any $K$ larger than that, $K$ could be improved to at least as good as the total sum of the pizza prices. We repeat the process by looking for satisfiable instances of that $K'$ that are smaller than our previous $K$ and stop whenever we cannot satisfy $K'$, meaning that $K'$ is the least possible value of $K$.
\\
\\
\tab In this document, we first specify the problem by defining our vocabulary $\mathcal{L}$ of functions and constant symbols for an $\mathcal{L}$-structure $\mathcal{M}$. Then we will show that, to solve this problem, we must find a vocabulary $\mathcal{L'}$ (with a $\mathcal{L'}$-structure $\mathcal{M'}$) that extends $\mathcal{L}$ such that when we find a satisfiable instance of $M$ for all constraints in $\mathcal{L'}$, we find a satisfying instance for the initial problem, since $\mathcal{M'}$ and $\mathcal{M}$ share the same universe $M$. After specifying our vocabularies and constraint relations, we will show some tests instances of the problem run on \textbf{Minizinc} solver that will be then have their performance empirically evaluated. Finally, we will have a short discussion about the process of solving the Pizza problem.
\section{Specification}
The pizza problem is as follows:
\begin{itemize}
\item The final goal is to obtain all ordered pizzas for the least possible cost.
\item A voucher is a pair of numbers $(a, b)$ where you pay for $a$ pizzas and obtain $b$ pizzas for free as long as each of the $b$ pizzas cost no more than each of the $a$ pizzas.
\item A voucher does not need to be completely used and not all vouchers need to be used.
\end{itemize}
\tab A vocabulary $\mathcal{L}$ then can be defined by the symbols $[ price, buy, free, n, m, k ]$ where $n$ is the number of pizzas, $m$ is the number of vouchers, $k$ is the cost bound, $price : [n] \rightarrow \mathbb{N}$ is an unary function that maps the price of each one of the $n$ pizzas, $buy : [m] \rightarrow \mathbb{N}$ is an unary function that maps the number of pizzas that must be bought for each one of the $m$ vouchers and $free : [m] \rightarrow \mathbb{N}$ is an unary function that maps the number of pizzas that come for free when a voucher is used, for each one of the $m$ vouchers. The universe $M$ are all the numbers appearing in the structure. The \textbf{Minizinc} equivalent form of $\mathcal{L}$ is:
\begin{algorithmic}
\State \textbf{int}: n;
\State \textbf{array}[1..n] \textbf{of int}: price;
\State \textbf{int}: m;
\State \textbf{array}[1..m] \textbf{of int}: buy;
\State \textbf{array}[1..m] \textbf{of int}: free;
\\
\end{algorithmic}
\tab We need to find an assignment of pizzas and vouchers that minimize the total cost $k$ and for this reason we will create a vocabulary $\mathcal{L'}$ that extends $\mathcal{L}$, where $\mathcal{L}$  and $\mathcal{L'}$ share the same universe. Let $\mathcal{L'}$ be defined by the symbols in $\mathcal{L}$ and the symbols $[ Paid, Used, Justifies, UsedFor ]$, where the symbol $Paid : [n] \rightarrow \{ 0, 1\}$ is an unary symbol representing the set of paid pizzas, $Used: [m] \rightarrow \{ 0, 1\}$ is an unary symbol representing the set of used vouchers, $Justifies: [m] \rightarrow [n] \rightarrow \{ 0, 1\}$ is a binary symbol representing the set of vouchers $v$ that will be used by paying for pizzas $p$ and $UsedFor: [m] \rightarrow [n] \rightarrow \{ 0, 1\}$ is a binary symbol representing the set of free pizzas $p$ that were obtained by using vouchers $v$. The \textbf{Minizinc} equivalent form of $\mathcal{L'}$ is:
\begin{algorithmic}
\State \textbf{array}$[1..n]$ \textbf{of var bool}: Paid;
\State \textbf{array}$[1..m]$ \textbf{of var bool}: Used;
\State \textbf{array}$[1..m, 1..n]$ \textbf{of var bool}: Justifies;
\State \textbf{array}$[1..m, 1..n]$ \textbf{of var bool}: UsedFor;
\\
\end{algorithmic}
\tab To find a solution to instance $\mathcal{L}$ we must solve for vocabulary $\mathcal{L'}$ and $\mathcal{L'}$-structure $\mathcal{M}$ and satisfy the problem constraints in \textbf{Minizinc}:
\begin{itemize}
\item If we paid for a pizza $p$, then it cannot be in the set of free pizzas
\begin{algorithmic}
\State \textbf{constraint forall} ($p$ \textbf{in} $1..n$)
\State \tab\tab $(Paid[p]\leftrightarrow
           \textbf{not exists}(v \text{ in } 1..m)(UsedFor[v, p]));$
\\
\end{algorithmic}
\item If voucher $v$ is used, then it must get at least one free pizza $p$ with it
\begin{algorithmic}
\State \textbf{constraint forall} ($v$ \textbf{in} $1..m$)
\State \tab\tab $(Used[v]\leftrightarrow
           \textbf{exists}(p \textbf{ in } 1..n)(UsedFor[v, p]));$
\\
\end{algorithmic}
\item Any used voucher $v$ must be justified by paying for exactly some pizzas $p$
\begin{algorithmic}
\State \textbf{constraint forall} ($v$ \textbf{in} $1..m$)
\State \tab\tab $(Used[v]\rightarrow$
\State \tab\tab\tab $\textbf{sum}(p \text{ in } 1..n)(Justifies[v, p]) >= buy[v]);$
\\
\end{algorithmic}
\item The number of free pizzas cannot be greater than what is possible by using voucher $v$
\begin{algorithmic}
\State \textbf{constraint forall} ($v$ \textbf{in} $1..m$)
\State \tab\tab $(\textbf{sum}(p \text{ in } 1..n)(UsedFor[v, p]) <= free[v])$;
\\
\end{algorithmic}
\item For every two pizzas $p_1, p_2$, if $p_1$ was a pizza we got for free with voucher $v$ and $p_2$ is a pizza we paid with voucher $v$, then the price of $p_1$ must be less or equal the price of $p_2$
\begin{algorithmic}
\State \textbf{constraint forall}($p1$, $p2$ \textbf{in} $1..n$ \textbf{where} $p1 \text{ != } p2,$
\State \tab\tab\tab\tab\tab\tab\tab\tab $\text{ } c$ \textbf{in} $1..m$)
\State \tab\tab $((UsedFor[c, p1] \land Justifies[c, p2]) \rightarrow$
\State \tab\tab\tab\tab $price[p1] <= price[p2]);$
\\
\end{algorithmic}
\item Two vouchers $v_1, v_2$ cannot be justified by using the same paid pizza $p$
\begin{algorithmic}
\State \textbf{constraint forall} ($v1, v2$ \textbf{in} $1..m$ \textbf{where} $v1$ != $v2,$
\State \tab\tab\tab\tab\tab\tab\tab\tab $\text{ } p$ \textbf{in} $1..n$)
\State \tab\tab $(Justifies[v1, p] \rightarrow \textbf{not} (Justifies[v2, p]));$
\\
\end{algorithmic}
\item We pay for every pizza $p$ used to justify use of a voucher $v$
\begin{algorithmic}
\State \textbf{constraint forall} ($p$ \textbf{in} $1..n$, $v$ \textbf{in} $1..m$)
\State \tab\tab $(Justifies[v, p] \rightarrow Paid[p]);$
\\
\end{algorithmic}
\item The pairs in $Justifies$ and $UsedFor$ can only be consisting of a voucher $v$ and a pizza $p$
\begin{algorithmic}
\State \textbf{constraint forall} ($v$ \textbf{in} $1..m$, $p$ \textbf{in} $1..n$)
\State \tab\tab $(Justifies[v, p] \rightarrow (v \textbf{ in } 1..m \land p \textbf{ in } 1..n));$
\State \textbf{constraint forall} ($v$ \textbf{in} $1..m$, $p$ \textbf{in} $1..n$)
\State \tab\tab $(Used[v, p] \rightarrow (v \textbf{ in } 1..m \land p \textbf{ in } 1..n));$
\\
\end{algorithmic}
\item The total cost ($k$, the sum of all paid pizzas) must be less or equal the sum of all pizza prices
\begin{algorithmic}
\State \textbf{int}: $total$ = \textbf{sum}($price$);
\State \textbf{var int}: $k$ = (\textbf{sum}($p$ \textbf{in} $1..n)(Paid[p] * price[p]));$
\State \textbf{constraint} $k <= total;$
\\
\end{algorithmic}
\item And finally, we want to minimize the whole cost $K$
\begin{algorithmic}
\State \textbf{solve minimize} $k$;
\\
\end{algorithmic}
\end{itemize}
\section{Testing}
We created initially three test instances (the ones given in the \textit{LP/CP Programming Contest 2015}) so to test if our specification was correct as defined on the contest and added seven so to evaluate how efficient the specification solve different instances of the same problem. Each data in the test assign values to the number $n$ of pizzas, the number $m$ of vouchers, the map $price$ of pizzas prices and the maps $buy$ and $free$ of vouchers, therefore establishing the universe $M$ (all the numbers appearing in the structure). The detailed list of test instances were as below:
\begin{itemize}
\item Test 1: given in \textit{LP/CP Programming Contest 2015}
\begin{algorithmic}
\State $n = 4$;
\State $price = [10,5,20,15];$
\State $m = 2;$
\State $buy = [1,2];$
\State $free = [1,1];$
\\
\end{algorithmic}
\item Test 2: given in \textit{LP/CP Programming Contest 2015}
\begin{algorithmic}
\State $n = 4;$
\State $price = [10,15,20,15];$
\State $m = 7;$
\State $buy = [1,2,2,8,3,1,4];$
\State $free = [1,1,2,9,1,0,1];$
\\
\end{algorithmic}
\item Test 3: given in \textit{LP/CP Programming Contest 2015}
\begin{algorithmic}
\State $n = 10;$
\State $price = [70,10,60,60,30,100,60,40,60,20];$
\State $m = 4;$
\State $buy = [1,2,1,1];$
\State $free = [1,1,1,0];$
\\
\end{algorithmic}
\item Test 4: Testing instances when all pizzas have same price 
\begin{algorithmic}
\State $n = 10;$
\State $price = [100,100,100,100,100,100,100,100,100,100];$
\State $m = 5;$
\State $buy = [3,1,1,2,3];$
\State $free = [3,1,1,1,2];$
\\
\end{algorithmic}
\item Test 5: Testing instances when all pizzas have prices mixed 
\begin{algorithmic}
\State $n = 9;$
\State $price = [7,20,80,47,54,68,46,38,7];$
\State $m = 4;$
\State $buy = [3,5,1,4];$
\State $free = [1,6,2,1];$
\\
\end{algorithmic}
\end{itemize}
\section{Empirical Performance}
\section{Discussion}
\section{Data}
\end{document}